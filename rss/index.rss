<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/" version="2.0"><channel><title>Project Journal by Erik Källman</title><description>Project Journal by Erik Källman</description><link>http://localhost:2368/</link><image><url>http://localhost:2368/favicon.png</url><title>Project Journal by Erik Källman</title><link>http://localhost:2368/</link></image><generator>Ghost 2.18</generator><lastBuildDate>Sat, 12 Oct 2019 10:06:39 GMT</lastBuildDate><atom:link href="http://localhost:2368/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title>Scatter - finally free in the wild</title><description>If I cannot read the code you used in your publication, I cannot trust the data you publish. </description><link>http://localhost:2368/scttr/</link><guid isPermaLink="false">5da0e551c8e096149e579a87</guid><category>scatter</category><category>research</category><dc:creator>Erik Källman</dc:creator><pubDate>Fri, 11 Oct 2019 20:56:16 GMT</pubDate><content:encoded>&lt;p&gt;One problem with writing code in academia is people don’t make research careers on writing good code.&lt;/p&gt;&lt;p&gt;As a researcher in the natural sciences, be surprised if anyone mentions your code at all. To a large extent what matters is if your code, in the immediate future, helps you get more science produced. This creates a situation where larger code bases are written in patch-work fashion on top of the previous generations of often times completely undocumented and poorly formatted, custom by-some-hacky-makescript-built code. Furthermore, only rarely is there anything resembling code review.&lt;/p&gt;&lt;p&gt;Yet still, science depends on its code being transparently &lt;strong&gt;accessible&lt;/strong&gt;, &lt;strong&gt;readable&lt;/strong&gt;,  and &lt;strong&gt;maintainable&lt;/strong&gt;. These points cannot be overemphesized. If I cannot read the code you used in your publication, I cannot trust the data you publish. Further more, often times licensing is completely missing, even though lots of research gets funded by tax-payer money. &lt;/p&gt;&lt;p&gt;So with that I use this saturday glass of wine to perform a quiet protest in publishing a tool i have been using that goes halfway on the problems mentioned. &lt;/p&gt;&lt;p&gt;Scatter is the tool I have been iterating over during the past years to generate RIXS (Resonant Inelastic X-ray Scattering) maps for transition metal complexes - a large part of my research for the past four years. &lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/erikkallman/scttr"&gt;Here is a link to its repository. &lt;/a&gt;&lt;/p&gt;&lt;p&gt;If you spend some time looking over the code and tell me what you think about it, I'll give you free lunch.&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;!--kg-card-begin: gallery--&gt;&lt;figure class="kg-card kg-gallery-card kg-width-wide"&gt;&lt;div class="kg-gallery-container"&gt;&lt;div class="kg-gallery-row"&gt;&lt;div class="kg-gallery-image"&gt;&lt;img src="http://localhost:2368/content/images/2019/10/rixsmaps_v5-1.png" width="5632" height="2920"&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/figure&gt;&lt;!--kg-card-end: gallery--&gt;</content:encoded></item><item><title>Nixu 2019 CTF Writeup: Plumbing</title><description>In this particular challenge, we need to take a deeper-than-average dive into how Git builds its commit messages. Super cool, and pretty simple. </description><link>http://localhost:2368/writeup-plumbing/</link><guid isPermaLink="false">5cfff5aac3dbaa1e5b73c4a8</guid><category>Nixu</category><category>Write-up</category><category>CTF</category><category>cyber security</category><dc:creator>Erik Källman</dc:creator><pubDate>Fri, 14 Jun 2019 09:48:44 GMT</pubDate><content:encoded>&lt;p&gt;In this particular challenge, we need to take a deeper-than-average dive into how Git builds its commit messages. Super cool, and pretty simple. &lt;br&gt;&lt;br&gt;As wonderful of a tool git is, this is not stuff we could motivate ourselves to do on our spare time. But if someone were to wrap it into a neat CTF challenge, and provide us with imaginary internet points for completing that challenge, we would have jumped right at it. &lt;br&gt;&lt;br&gt;Someone did just that.&lt;/p&gt;&lt;!--kg-card-begin: image--&gt;&lt;figure class="kg-card kg-image-card"&gt;&lt;img src="http://localhost:2368/content/images/2019/10/writeup.jpg" class="kg-image"&gt;&lt;/figure&gt;&lt;!--kg-card-end: image--&gt;&lt;h2 id="1-introduction"&gt;1. Introduction&lt;/h2&gt;&lt;p&gt;We are presented with a text file containing the return of someone executing running "git log" in terminal:&lt;/p&gt;&lt;p&gt;commit da38267d15c7f1983cbb34be0dd93e5e0a8b6c3d&lt;br&gt;Author: admin &lt;a&gt;admin@example.com&lt;/a&gt;&lt;br&gt;Date:   Mon Nov 26 13:13:13 2018 +0200&lt;/p&gt;&lt;!--kg-card-begin: code--&gt;&lt;pre&gt;&lt;code&gt;Wrap inside NIXU{}
&lt;/code&gt;&lt;/pre&gt;&lt;!--kg-card-end: code--&gt;&lt;p&gt;commit 983db0dd8771fcfb236beb8273c014171ffb3cef&lt;br&gt;Author: admin &lt;a&gt;admin@example.com&lt;/a&gt;&lt;br&gt;Date:   Tue Feb 2 13:13:13 2016 +0200&lt;/p&gt;&lt;!--kg-card-begin: code--&gt;&lt;pre&gt;&lt;code&gt;Decode phonetic alphabet (lowercase, no whitespace)
&lt;/code&gt;&lt;/pre&gt;&lt;!--kg-card-end: code--&gt;&lt;p&gt;And so on, and so forth.&lt;/p&gt;&lt;p&gt;Supposedly, inside this commit tree hides information on a encryption key to the backups of the system that Nixu garbled. This is all lore of course. Spice to get us in the mood to hack a little. There is no secure key hiding in this burning trash pile of an encryption method. We need to embrace that. &lt;/p&gt;&lt;p&gt;So, from this sequence of commit messages, and trusting the commit comments, we must work our way through each commit and finally arrive at the key that was garbled.&lt;/p&gt;&lt;h2 id="2-background"&gt;2. Background&lt;/h2&gt;&lt;p&gt;In all problems of this type, it helps chalking up our answer to asking ourselves "what is known?" without wandering too far towards the philosophical end of that question.&lt;/p&gt;&lt;p&gt;With the information given to us, this is known:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;A sequence of non negative integers were drawn, one per commit, from a set of "dice distributions": a 1d9, 1d100, and a 1d10000000 (ouch). The drawn numbers were added to the end of a number sequence.&lt;/li&gt;&lt;li&gt;After the whole sequence of pseudo-random numbers is drawn, a series of operations were applied to change that sequence further.&lt;/li&gt;&lt;li&gt;The commit messages describe the operations performed. &lt;/li&gt;&lt;li&gt;The metadata for each commit is provided in the git log print out.&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;So far we are dealing with obvious information. However, like many CTF problems, we cannot solve them unless we more or less understand what we are doing. &lt;br&gt;&lt;br&gt;The crucial piece of extra information needed here, is that each commit contains a commit hash. This is the SHA1 hash printed after the "commit" word in the commit message, which relates to the content in the directory (we will get back to this). In this challenge, we need to understand that commit hash, and the format of the commit message, to work our way from start to end of that commit tree.&lt;/p&gt;&lt;h3 id="2-1-the-git-commit-message"&gt;2.1 The Git commit message&lt;/h3&gt;&lt;p&gt;Even though I use git for all my revision control (text, code, what have you), I haven't given the structure of the commit hash much thought. Thankfully, people have already tried to recreate commit hashes and also &lt;a href="https://gist.github.com/masak/2415865"&gt;uploaded their struggle to github&lt;/a&gt;. In short, the hash contains:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;the number of characters in the commit message &lt;/li&gt;&lt;li&gt;the tree hash (a hash of the source directory)&lt;/li&gt;&lt;li&gt;the commit hash of the parent commit (this is omitted if we are at the first commit)&lt;/li&gt;&lt;li&gt;the author info (name, email, timestamp and timezone) &lt;/li&gt;&lt;li&gt;committer info (name, email, timestamp and timezone)&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;The author and committer information need not be the same, where the author is the user that wrote the data that was committed. However, the user committing that data does not need to be the author, and the authoring does not need to be done at the same time as the commit (yes, this is obvious, but you know what? there it is).&lt;/p&gt;&lt;!--kg-card-begin: image--&gt;&lt;figure class="kg-card kg-image-card"&gt;&lt;img src="http://localhost:2368/content/images/2019/06/64206059_468964043911766_5457677533585604608_n.jpg" class="kg-image"&gt;&lt;/figure&gt;&lt;!--kg-card-end: image--&gt;&lt;h2 id="3-solution"&gt;3. Solution&lt;/h2&gt;&lt;p&gt;The only unknown piece of information is the tree hash. If we assume that the source directory contains only the file of interest (the flag.txt file), and that the commit comments are truthful, we have a problem that we can brute force and formulate in one sentence:&lt;br&gt;&lt;br&gt;&lt;em&gt;If we iterate through every possible number in each distribution, and from each new sequence of numbers can generate our own commit message, the correctly drawn number will be identified among our drawn numbers by having the same commit hash as provided in the git log for that specific step in the git tree.&lt;/em&gt;&lt;br&gt;&lt;br&gt;While the implementation may differ, this is the problem we are trying to solve. It is not the smoothest or fastest method, but boy oh boy is it a good feeling waking up in the morning while your computer correctly sampled 17 out of 17*10 000 000 numbers. &lt;br&gt;&lt;br&gt;Before dinner we quickly tried to code up an implementation based on simply calling git from python to verify our previous assumptions about the problem. The first few commits produces a sequence that is a few numbers long, and if we got the first commit hash right, we would know if we were on the right track.&lt;/p&gt;&lt;p&gt;Obviously, this is not a complete solution, due to the extensive i/o and overhead of creating new processes when executing shell commands through python. For shits and giggles, our timing estimate for the worst case scenario landed us in roughly 40 days until completion. Our patience gave us about 1/40th of that time to work with.&lt;br&gt;&lt;br&gt;We then proceeded to implement our own commit generator. Thankfully, we found a &lt;a href="https://github.com/chris3torek/scripts/blob/master/githash.py"&gt;neat script&lt;/a&gt; that could provide us with an algorithm for producing tree hashes, which is the only tricky part in all of this.&lt;br&gt;&lt;br&gt;So as the busy monkey that we are, we coded up our little script and waited over night. In the morning we performed the last steps of string garbling to arrive at our flag, at last:&lt;/p&gt;&lt;!--kg-card-begin: markdown--&gt;&lt;p&gt;4B2D656E6C0A787679620A50756E657976720A717279676E0A7A62776E0A476E61620A6776666E0A666E6F6E0A -&amp;gt; K-enl xvyb Puneyvr qrygn zbwn Gnab gvfn fnon -&amp;gt; X-ray kilo Charlie delta moja Tano tisa saba -&amp;gt; X-ray kilo Charlie delta one Five nine seven -&amp;gt; xkcd1597 -&amp;gt; NIXU{xkcd1597}&lt;/p&gt;
&lt;!--kg-card-end: markdown--&gt;&lt;p&gt;What we wrote was not pretty, but neither is translation of a byte string from English to Swahili as a method of encryption. Or was it simply a method to provide a convoluted link to a &lt;a href="https://xkcd.com/1597/"&gt;relevant xkcd&lt;/a&gt;? The world will never know.&lt;/p&gt;&lt;p&gt; &lt;br&gt;Anyway,&lt;a href="https://github.com/erikkallman/nixu_2019_ctf"&gt; here is the script.&lt;/a&gt;&lt;br&gt;&lt;br&gt;&lt;em&gt;&lt;br&gt; &lt;/em&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;</content:encoded></item></channel></rss>